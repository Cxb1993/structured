//////////////////////////////////////////////////
// Copyright (c) INRIA (France) 2011, 2012, 2013
// 
// This file is part of inria-mvs. You can redistribute it and/or
// modify it under the terms of the GNU General Public License.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
// 
// Author: Jean-Paul CHIEZE <jean-paul.chieze@inria.fr>
// 
//////////////////////////////////////////////////

#include "delaunay.h"
#include <time.h>

#ifdef _OPENMP
#include <omp.h>
#endif

/** \file delaunay.cpp
 @brief Main program for delaunay triangulation and ray tracing
 **/

static double box_lgr(0.);

/**
 * print the unsage message
 @param prog : program name
 **/
void usage(char *prog) {
#ifdef USE_BUNDLER
  std::cout << "Usage : " << prog << " <cam_points> <bundler-file> [-D debug-level] [-o outfile] [-a coef_min coef_max] " << std::endl << std::endl;
  std::cout << "   Make a delaunay triangulation with bundler points and camera positions," << std::endl;
#else
  std::cout << "Usage : " << prog << " <cam_points> <points-basename> [-D debug-level] [-o outfile] [-a coef_min coef_max] " << std::endl << std::endl;
  std::cout << "   Make a delaunay triangulation with PMVS points and camera positions," << std::endl;
#endif
  std::cout << "   and compute intersections of tetrahedrons with rays issued from camera points." << std::endl << std::endl;
  std::cout << "     <cam_points> : ply file of camera positions, with color attribute (generated by tool **drawcameras.py**)." << std::endl;
#ifdef USE_BUNDLER
  std::cout << "     <bundler-file> : bundler result, should be pmvs/bundle.rd.out." << std::endl;
#else
  std::cout << "     <points-basename> : basename for .ply and .patch files" << std::endl;
#endif
  std::cout << "     -D : debug level, level / 10 for display, level % 10 for interactivity" << std::endl;
  std::cout << "     -o : result file (default output.cgal)." << std::endl;
  std::cout << "     -a : add a point (barycenter) to \"large\" tretrahedrons, i.e with an edge >= coef_min*average-edge-length and <= coef_max*average-edge-length." << std::endl;
  exit(1);
}


/**
  Find cells intersected by the ray joining camera num icam to point num ipt

   @param points :  vector of points
   @param  cells : incident cells at camera point
   @param ifacets : vector of facets of incident cells to be tested.
   @param itf0 : where to start in ifacets
   @param icam : cam index
   @param vcam : vertex of cam
   @param ipt : target point index
	
   @param[out] marked_cells : intersected cells are added to this vector
   @param[out] stats : statistics 
   @return iterator where to start in the camera incident facet vector (try to optimize initial facets search).
 */
std::vector<Facet>::iterator check_point(Delaunay &Tr,std::vector<Cell_handle> &marked_cells,TPoint &points,std::vector<Cell_handle> &cells,std::vector<Facet> &ifacets,std::vector<Facet>::iterator itf0,int icam,Vertex_handle vcam,int ipt,TrStats *stats,CGAL::Geomview_stream &gv) throw(const char *){
  if(debug_stop > 1) std::cout << "\n\nCAM  " << icam << " : " << ipt << std::endl;
  if(debug_stop > 1) {
    prompt("GO");
  }
  Segment seg(points[icam].first,points[ipt].first);
  if(debug_stop > 1) std::cout << "NB CELLS " << std::distance(cells.begin(),cells.end()) << 
    " FACETS : " << ifacets.size() << std::endl;

  Circulator ifc0(ifacets.begin(),ifacets.end(),itf0);
  Circulator ifc = ifc0;
  std::vector<Facet> *facets = new std::vector<Facet>();
  do {
    Facet f = *ifc++;
    facets->push_back(f);
  }  while (ifc != ifc0);

  Intersect in_inter, out_inter;
  in_inter.int_type = INT_VERTEX;
  in_inter.v1 = vcam;
  bool first_step = true;
  std::vector<Facet>::iterator itres;
  int step = 0;
  int err = 0;
  while (facets->size() > 0) {
    if(debug_vis > 2) {
      draw_all(gv,Tr);
      draw_seg(gv,seg);
      //      draw_tetra(Tr,cells,gv);
      draw_facets(Tr,*facets,gv);
      if (icam == 172 && ipt == 22) {
	prompt("TETRAS ");
	//draw_all(gv,Tr);
	gv.clear();
	draw_seg(gv,seg);
	draw_line_tetra(Tr,cells,gv);
	prompt("Next ");
      }
    }
    stats->nb_test_facets += facets->size();
    int nb0 = facets->size();
    step++;
    int nb_tested = 0;
    facets = intersect(&err,&nb_tested,seg,in_inter,out_inter,facets,Tr,marked_cells,stats,gv);
    stats->nb_tested_facets += nb_tested;
    if(first_step) {
      stats->nb_tested_lv0 += nb_tested;
      first_step = false;
      int n = out_inter.intersected_facet;
      itres = ifacets.begin() + n;
    }
    if(err != 0) {
      printf("ERROR: no intersection; cam %d, point %d, step %d\n",icam,ipt,step);
      throw("Could not reach target point");
    }

    in_inter = out_inter;
    
    if(debug_stop > 1) {
      std::cout << "SEG " << seg << ", " << facets->size() << " FACETS" <<std::endl;
      if(debug_stop > 3)   prompt("");
    }
  }
  return itres;
}

void dump_cell(Cell_handle &c) {
  std::cout << "CELL ";
  for(int i= 0;i < 4;i++) {
    int j = c->vertex(i)->info();
    std::cout << " " << j;
  }
  std::cout << std::endl;
}

/**
  Find cells intersected by the rays joining the camera number icam to all its visible points.
  The number of intersections is added to field 'info' of cells

  @param points: vector of points
  @param icam : camera number
  @param vpatches : vector of indices of the points that are visible from the camera
	
 @param[out] stats : statistics
 */
void check_cam(Delaunay &Tr,TPoint &points,int icam,VisiblePatches *vpatches,TrStats *stats,CGAL::Geomview_stream &gv) throw(const char *){
  
  Locate_type lt;
  int li, lj;
  Cell_handle c = Tr.locate(points[icam].first,lt,li,lj);
  if(lt != Delaunay::VERTEX) 
    throw("query point should be on a vertex\n");
  Vertex_handle v = c->vertex(li);
  std::vector<Cell_handle> cells;
#pragma omp critical
  {
  Tr.finite_incident_cells(v,std::back_inserter(cells));
  }
  std::vector<Facet> facets;
#ifdef _OPENMP
#pragma omp critical
  {
      for (std::vector<Cell_handle>::iterator it = cells.begin();it != cells.end();it++) 
	(*it)->info() = MAX_INTERSECT;
  }

#endif
  for (std::vector<Cell_handle>::iterator it = cells.begin();it != cells.end();it++) {
    int ip = (*it)->index(v);
#ifndef _OPENMP
    (*it)->info() = MAX_INTERSECT;
#endif
    facets.push_back(Facet(*it,ip));
  }
  stats->nb_tetra0 += facets.size();
  stats->nb_rayons += vpatches->size();

  int k = 0;
  bool first = true;
  for(VisiblePatches::iterator itp = vpatches->begin();itp != vpatches->end();itp++) {
    if(points[*itp].second < 0) continue; // removed point
    std::vector<Cell_handle> marked_cells;
    std::vector<Facet>::iterator itf = facets.begin();
    std::vector<Facet>::iterator it2 =  check_point(Tr,marked_cells,points,cells,facets,itf,icam,v,*itp,stats,gv);
#pragma omp critical
    {
      for(std::vector<Cell_handle>::iterator it = marked_cells.begin();it != marked_cells.end();it++) {
	if((*it)->info() < MAX_INTERSECT) (*it)->info() += 2;
      }
    }
    
    if(first) {
      itf = it2;
      first = false;
    }
  }

}

/**
  Dump to a binary file all data needed to extract surface facets extraction :
  
  @param file : name of file
  @param T : the delaunay structure
  @param cam_points : vector of cameras coords and index in cam_points.
  @param pcolors : vector of initial points colors
  @param normals : vector of intitial points normals
  @param bb : bounding box of PMVS points
  @param totpts : total number of points (PMVS points + camera points)
  @param nbpts0 : nb of points without cameras (= index of 1st camera)
  @param cameras : vector of valid cameras giving their index in cam_points
  @param bad_cameras : vector of bad cameras giving their index in cam_points
  @param image_patches : map of visible points per camera
  @param edge_mean : average edge length (PMVS2 points only)
  @param tetra_coefs : the coefficients of option -a

  The structure of the file is :
  - 4 bytes version (CGxx)
  - delaunay data
  - 6 * float : bounding box (without cams)
  - 3 * float : average edge length (in pmvs points), 0 0 or coefs min and max used for points addition in large tetras
  - int : nbcams = nb of "good" cameras
  - npts * 3 uchars : colors of points
  - bool : 'with_normals'
  - npts * 3-floats : normals of finite vertices
  - nbcams * 2 * int : nbcams camera indexes (in finite vertices list), nbcams original cameras nums
  - nbcell * int : finites cells info
  - nbcams * (points visible by each camera) :
    - int : cam num
    - int : nb of visible points
    - nbv * int : indexes (in finite vertices list) of visible points
 - int : nbbadcams
 - nbbadcams * 3 float : bad cameras coords
**/
void dump_data(char *file,Delaunay &T,TPoint &cam_points,TPoint &points,PointColor &pcolors,std::vector<Point> &normals,CGAL::Bbox_3 &bb,int totpts,int nbpts0,std::vector<int> &cameras,std::vector<int> &bad_cameras,std::map<int, VisiblePatches*> &image_patches,float edge_mean,float *tetra_coefs)
{
  std::ofstream oFileT;
  int nbcams = cameras.size();
  oFileT.open(file,std::ios::out);
  CGAL::set_binary_mode(oFileT);
  oFileT.write(file_version,4);
  oFileT << T;
  float box[6];
  box[0] = bb.xmin();
  box[1] = bb.ymin();
  box[2] = bb.zmin();
  box[3] = bb.xmax();
  box[4] = bb.ymax();
  box[5] = bb.zmax();
  oFileT.write((char *)box,sizeof(box));
  oFileT.write((char *)&edge_mean,sizeof(float));
  oFileT.write((char *)tetra_coefs,2 * sizeof(float));
  oFileT.write((char *)&nbcams,sizeof(nbcams));

  Delaunay::Finite_vertices_iterator it;
  int cam_index[2 * nbcams];
  int j = 0;
  int k;
  int *new_vert_index = new int[totpts];
  for(it = T.finite_vertices_begin();it != T.finite_vertices_end();it++,j++) {
    unsigned char tmp[3];
    int i = it->info();
    if(i >= nbpts0) {
      k = i - nbpts0;
      cam_index[k] = j;
      cam_index[k+nbcams] = cameras[k]; // cam num
    }
    new_vert_index[i] = j;
    tmp[0] = pcolors[i].red();
    tmp[1] = pcolors[i].green();
    tmp[2] = pcolors[i].blue();
    oFileT.write((char *)tmp,(int)sizeof(tmp));
  }
  bool with_normals = false;
  if(normals.size() != pcolors.size()) {
    oFileT.write((char *)&with_normals,(int)sizeof(with_normals));
  } else {
    with_normals = true;
    oFileT.write((char *)&with_normals,sizeof(with_normals));
    float tmp[3];
    for(it = T.finite_vertices_begin();it != T.finite_vertices_end();it++) {
      int i = it->info();
      tmp[0] = normals[i].x();
      tmp[1] = normals[i].y();
      tmp[2] = normals[i].z();
      oFileT.write((char *)tmp,sizeof(tmp));
    }
  }
  // cameras indexes
  oFileT.write((char *)cam_index,2 * nbcams * sizeof(int));
  // cells info
  Delaunay::Finite_cells_iterator cit;
  int icell = 0;
  for (cit = T.finite_cells_begin(); cit != T.finite_cells_end(); ++cit,icell++) {
    int i = cit->info();
    //    std::cout << "I " << cit->info() << " : " << i << std::endl;
    oFileT.write((char *)&i,sizeof(i));
  }
  // visible points by camera : num cam, nb points, points indices
  for(int i = 0;i < nbcams;i++) {
    int icam = cameras[i];
    std::map<int, VisiblePatches*>::iterator itv = image_patches.find(icam);
    if(itv == image_patches.end()) throw("Internal error : corrupted cam list\n");
    VisiblePatches *patches = itv->second;
    int tmp[2];
    tmp[0] = i;
    
    int *pi0 = new int[patches->size()];
    int *pi = pi0;
    int nv = 0;
    for (VisiblePatches::iterator it = patches->begin();it != patches->end();it++) {
      if(points[*it].second < 0) continue;
      *pi++ = new_vert_index[*it];
      nv++;
    }
    tmp[1] = nv;
    oFileT.write((char *)tmp,sizeof(tmp));
    if (nv > 0)
      oFileT.write((char *)pi0,nv * sizeof(int));
    delete[] pi0;
    
  }

  // bad cameras coords
  int nb_badcams = bad_cameras.size();
  oFileT.write((char *)&nb_badcams,sizeof(nb_badcams));
  float *pf0 = new float[3 * nb_badcams];
  float *pf = pf0;
  int *pi0 = new int[nb_badcams];
  int *pi = pi0;
  for (int i = 0;i < nb_badcams;i++) {
    int icam = bad_cameras[i];
    Point p = cam_points[icam].first;
    *pf++ = p.x();
    *pf++ = p.y();
    *pf++ = p.z();
    *pi++ = icam;
  }
  oFileT.write((char *)pf0,3 * nb_badcams * sizeof(float));
  // and actual cam indexes
  oFileT.write((char *)pi0,nb_badcams * sizeof(int));
  delete[] pf0;
  delete[] pi0;

  oFileT.close();
}

#ifdef USE_BUNDLER
CGAL::Bbox_3 read_bundler(const char *filename,TPoint &points,PointColor &colors,int nbcams,std::map<int, VisiblePatches *> &image_patches);
#endif

// visu geomview de demo/Triangulation_3_Geomview_demos/Triangulation_3_demo.cpp
int main(int argc,char **argv)
{
#ifdef __USE_POSIX
  struct timespec tstart, tstart2, tend;
#else
  time_t tstart, tstart2, tend;
#endif
  int firstcam = 0;
  char *outfile = "output.cgal";
  float tetra_coefs[] = {0.,0.};
  if(argc < 3 || argc > 9) usage(argv[0]);
  for (int i = 3;i < argc;) {
    int incr = 2;
    int ires;
    if(mygetopt("-D",OPT_INT,i,argc,argv,&ires)) {
      debug_stop = ires % 10;
      debug_vis = ires / 10;
      if(debug_vis > 0) gv_on = true;
    } else if(mygetopt("-o",OPT_STRING,i,argc,argv,&outfile)) {
      ;
    } else if(mygetopt("-a",OPT_FLOAT,i,argc,argv,tetra_coefs,2)) {
      incr = 3;
      if (tetra_coefs[0] < 0.) tetra_coefs[0] = 0.;
      if (tetra_coefs[1] < tetra_coefs[0]) tetra_coefs[1] = tetra_coefs[0];
    } else usage(argv[0]);
    i += incr;
  }

  int nbcams(0), nbpts0(0);
  TPoint points;
  TPoint cam_points;
  PointColor pcolors;
  PointColor cam_colors;
  std::vector<Point> normals;
  std::vector<Point> cam_normals;
  std::map<int, VisiblePatches*> image_patches;
  CGAL::Bbox_3 bb;
#ifdef __USE_POSIX
  clock_gettime(CLOCK_REALTIME,&tstart);
#else
  tstart = time(NULL);
#endif
  try {
    read_ply(argv[1],cam_points,cam_normals,cam_colors);
    nbcams = cam_points.size();
    if(cam_normals.size() == 0)
      cam_normals.resize(nbcams,Point(1.,1.,1.));
#ifdef USE_BUNDLER
    bb = read_bundler(argv[2],points,pcolors,nbcams,image_patches);
    nbpts0 = points.size();
#else // not USE_BUNDLER
    char tmp[512];
    snprintf(tmp,512,"%s.ply",argv[2]);
    bool no_points = false;
    std::ifstream ifstr;
    ifstr.open(tmp);
    if(! ifstr.good())
      no_points = true;
    else {
      ifstr.close();
      bb = read_ply(tmp,points,normals,pcolors);
      double dx = bb.xmax() - bb.xmin();
      double dy = bb.ymax() - bb.ymin();
      double dz = bb.zmax() - bb.zmin();
      Segment s = Segment(Point(bb.xmin(), bb.ymin(),bb.zmin()),Point(bb.xmax(), bb.ymax(),bb.zmax()));
      box_lgr = s.squared_length();
      if(normals.size() < points.size()) normals.clear();
    }
    snprintf(tmp,512,"%s.patch",argv[2]);
    read_patches(tmp,0,nbcams,points,image_patches,no_points);
    nbpts0 = points.size();
    if(no_points) {
      normals.clear();
      pcolors.resize(points.size(),CGAL::Color(128,128,128));
    }
#endif // USE_BUNDLER
  }
  catch(char const *_e) {
    std::cout << "ERROR " << _e << std::endl;
    return 1;
    
  }
#ifdef __USE_POSIX
  clock_gettime(CLOCK_REALTIME,&tend);
#else
  tend = time(NULL);
#endif
  std::cout << "Read took " << delta_t(&tstart,&tend) << "s" << std::endl;
  // 1. delaunay on pmvs points
#ifdef __USE_POSIX
  clock_gettime(CLOCK_REALTIME,&tstart);
#else
  tstart = time(NULL);
#endif
  Delaunay T( points.begin(),points.end() );
  float edge_mean = mean_edge(T);

  // add points if needed
  if (tetra_coefs[0] > 0.) {
#ifdef __USE_POSIX
    clock_gettime(CLOCK_REALTIME,&tstart2);
#else
    tstart2 = time(NULL);
#endif
   //  add a point to "large" cells
    // 1st compute edge length average
    float edge_min = tetra_coefs[0] * tetra_coefs[0] * edge_mean;
    float edge_max = tetra_coefs[1] * tetra_coefs[1] * edge_mean;
    // add points
    int nbadd = 0;
    //    for (int i = 0; i < 10;i++) {
      int nb = add_cells(T,edge_min,edge_max,points,pcolors,normals);
      nbadd += nb;
      //      std::cout << "ITER " << i << " added " << nb << " => " << nbadd << std::endl;
      //    }
#ifdef __USE_POSIX
      clock_gettime(CLOCK_REALTIME,&tend);
#else
      tend = time(NULL);
#endif
    std::cout << "splitting large cells took " << delta_t(&tstart2,&tend) << "s, " << nbadd << " points added" << std::endl;

    nbpts0 = points.size();
  }
#if 1
  // verif points
  for(Delaunay::Finite_vertices_iterator it = T.finite_vertices_begin();it != T.finite_vertices_end();it++) {
    int j = it->info();
    if (j < 0 || j > points.size()) {
      std::cout << "BAD J " << j << std::endl;
      exit(2);
    }
    std::pair<Point,int> p = points[j];
    if(p.second != j) {
      std::cout << "ERR on point " << p.first << ", j " << j << " " << p.second << std::endl;
      exit(2);
    }
  }
#endif
  // add cameras points to delaunay
  std::vector<int> cameras;
  std::vector<int> bad_cameras;
  int j = nbpts0;
  for(int icam = 0;icam < nbcams;icam++) {
    std::map<int, VisiblePatches*>::iterator it = image_patches.find(icam);
    if (it != image_patches.end()) {
      std::pair<Point,int> p = cam_points[icam];
      p.second = j++;
      points.push_back(p);
      normals.push_back(cam_normals[icam]);
      pcolors.push_back(cam_colors[icam]);
      cameras.push_back(icam);
    } else
      bad_cameras.push_back(icam);
  }
  TPoint::iterator it = points.begin() + nbpts0;
  T.insert(it,points.end());
  std::cout << nbpts0 << " PMVS2 points, " << cameras.size() << " valid cameras / " << nbcams << std::endl;

#ifdef __USE_POSIX
  clock_gettime(CLOCK_REALTIME,&tend);
#else
  tend = time(NULL);
#endif
  std::cout << "Delaunay took " << delta_t(&tstart,&tend) << "s" << std::endl;
  // Check if the nb of points is compatible with the size of info()
  size_t k = points.size() - 1;
  if (k != points[k].second) {
    std::cout << "Sorry! the number of points " << k << " is greater than the index capacity." << std::endl;
    exit(2);
  }

  int nb_vertices = std::distance(T.finite_vertices_begin(),T.finite_vertices_end());
  std::cout << "VERTICES : " << nb_vertices << ", CELLS: " << std::distance(T.finite_cells_begin(),T.finite_cells_end()) << ", EDGES: " << std::distance(T.finite_edges_begin(),T.finite_edges_end()) << std::endl;

  // init cells info
  for (Delaunay::Finite_cells_iterator cit = T.finite_cells_begin(); cit != T.finite_cells_end(); ++cit) {
    cit->info() = 0;
  }

#ifdef __USE_POSIX
  clock_gettime(CLOCK_REALTIME,&tstart);
#else
  tstart = time(NULL);
#endif
  int totpts = points.size();

  bool *ipts = new bool[totpts];
  for (int i = 0;i < totpts;i++)
    *(ipts+i) = false;
  for(Delaunay::Finite_vertices_iterator it = T.finite_vertices_begin();it != T.finite_vertices_end();it++) {
    int j = it->info();
#if 1
    // some checking
    if(j >= totpts) {
      std::cout << "BAD POINT INFO : " << j << std::endl;
      abort();
    }
    if( *(ipts + j)) {
      std::cout << "BAD INFO : double ref to point " << j << std::endl;
      abort();
    }
#endif
    *(ipts + j) = true;
  }
  for (int i = 0;i < totpts;i++)
    if (! *(ipts+i))
      points[i].second = -1;
  delete[] ipts;
#ifdef __USE_POSIX
  clock_gettime(CLOCK_REALTIME,&tend);
#else
  tend = time(NULL);
#endif
  std::cout << "CHECK points took " << delta_t(&tstart,&tend) << "s" << std::endl;
  std::cout << "NB of points removed by delaunay " << (points.size() - nb_vertices) << std::endl;
#ifdef __USE_POSIX
  clock_gettime(CLOCK_REALTIME,&tstart);
#else
  tstart = time(NULL);
#endif

  CGAL::Geomview_stream *gv;
  if(debug_vis > 0) {
    gv = new CGAL::Geomview_stream(CGAL::Bbox_3(0,0,0, 2, 2, 2));
    gv->set_bg_color(CGAL::Color(200, 200, 200));
  }
  if(debug_vis > 0 && nbpts0 < 10000) draw_all(*gv,T);
#ifdef _OPENMP
  omp_set_nested(0);
  //  omp_set_dynamic(1);
  omp_set_dynamic(0); //  nb of threads will not depend on load
  int nbT = omp_get_num_procs();
  std::cout << "NB Threads " << nbT << std::endl;
#else
  int nbT = 1;
#endif
  //std::cout << nbT << " threads, " << nbcells << " cells" <<std::endl;
    //    std::map<int, VisiblePatches*>::iterator it  = image_patches.begin();
    bool error = false;
    TrStats *pstats[nbT];
    for(int i = 0;i < nbT;i++)
      pstats[i] = new TrStats();
#pragma omp parallel for num_threads(nbT)
  for(int i = firstcam;i < cameras.size();i++) {
    if (error) continue;
    int icam = cameras[i];
#ifdef _OPENMP
    int numth = omp_get_thread_num();
#else
    int numth = 0;
#endif
    try {
      //    for(int icam = 0;icam < nbcams;icam++) {
      std::map<int, VisiblePatches*>::iterator it = image_patches.find(icam);
      VisiblePatches vpatches(0);
      VisiblePatches *pvpatches;
      if (it != image_patches.end()) {
	pvpatches = it->second;
      } else {
	pvpatches = &vpatches;
      }
      if(debug_stop > 0 || nbcams > 10) 
	//	std::cout << "START CAM " << icam << " , " << pvpatches->size() << " PTS" << std::endl;
	printf("THREAD %d / %d START CAM %d, %d\n",numth,nbT,icam,pvpatches->size());
      if(debug_stop > 0) {
	prompt("GO");
      }
      check_cam(T,points,i + nbpts0,pvpatches,pstats[numth],*gv);
    }
    catch(char const *_e) {
      std::cout << "ERROR (cam " << icam << " , thr " << numth << ") : " << _e << std::endl;
      if(debug_vis > 0) delete gv;
      error = true;
      //return 1;
    }

  }
#ifdef __USE_POSIX
  clock_gettime(CLOCK_REALTIME,&tend);
#else
  tend = time(NULL);
#endif
  if (error) return 10;
  std::cout << "Ray tracing took " << delta_t(&tstart,&tend) << "s" << std::endl;
 
  TrStats *stats = pstats[0];
  for(int i = 1;i < nbT;i++)
    stats->sum(pstats[i]);
  std::cout << "  " << stats->nb_tested_facets << " / " << stats->nb_test_facets << " facets tested, " 
	    << stats->nb_tested_lv0 << " tested at cam points." << std::endl
	    << "  " << stats->nb_tot_intersect << " intersections found (" << stats->nb_intv << " on vertex, " 
	    << stats->nb_int_edge << " on edge)." << std::endl;
  std::cout << "  " << stats->nb_tetra0 << " camera tetrahedrons, " << stats->nb_rayons << " rays." << std::endl;
  std::cout << "Bounding BOX : " << bb << std::endl;
  std::cout << "DX " << bb.xmax() - bb.xmin() << ", DY " << bb.ymax() - bb.ymin() << ", DZ " << bb.zmax() - bb.zmin() << ", Average Edge Length " << sqrt(edge_mean) << std::endl;
#ifdef __USE_POSIX
  clock_gettime(CLOCK_REALTIME,&tstart);
#else
  tstart = time(NULL);
#endif
  dump_data(outfile,T,cam_points,points,pcolors,normals,bb,totpts,nbpts0,cameras,bad_cameras,image_patches,edge_mean,tetra_coefs);
#ifdef __USE_POSIX
  clock_gettime(CLOCK_REALTIME,&tend);
#else
  tend = time(NULL);
#endif
  std::cout << "Dump took " << delta_t(&tstart,&tend) << "s" << std::endl;

  if(debug_vis > 0) delete gv;
  return 0;
#if 0
#ifdef __USE_POSIX
  clock_gettime(CLOCK_REALTIME,&tstart);
#else
  tstart = time(NULL);
#endif
  delaunay_extract("newtr.ply",T,min_intersect,normals,pcolors,0,*gv);
#ifdef __USE_POSIX
  clock_gettime(CLOCK_REALTIME,&tend);
#else
  tend = time(NULL);
#endif
  std::cout << "Extraction took " << delta_t(&tstart,&tend) << "s" << std::endl;
  gv->set_wired(true);
  *gv << T;
  char ch;
  std::cin >> ch;
  return 0;
#endif
}
