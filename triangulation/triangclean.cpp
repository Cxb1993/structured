//////////////////////////////////////////////////
// Copyright (c) INRIA (France) 2011, 2012, 2013
// 
// This file is part of inria-mvs. You can redistribute it and/or
// modify it under the terms of the GNU General Public License.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
// 
// Author: Jean-Paul CHIEZE <jean-paul.chieze@inria.fr>
// 
//////////////////////////////////////////////////

#include "delaunay.h"
#include <math.h>
#include <ctype.h>

void usage(char *prog, bool fatal = true) {
  std::cout << "Usage : " << prog << " <input_cgal> <out_ply> [-e extract-mode] [-i min_intersect | -mxf nb-intersections] [-iw] [-a normals-angle] [-ct] [-lg lg_coef] [-s surf_coef][-sm lambda nb_iter]" << std::endl;
  const char *usage1 = "\n\
     Extract, from the result of program delauny, the facets of the surface of the scene,\n\
     and write the result to a ply file in binary format\n\
\n\
     The program first eliminates empty tretrahedrons\n\
     and then determines facets belonging to the surface.\n\
\n\
     <input_cgal> : data generated by program **delaunay**.\n\
     <out_ply> : .ply output file.\n\
     -e : extraction mode :\n\
          - 0 = use removed tretrahedrons\n\
          - 1 = use kept tretrahedrons\n\
          - 2 = extract all facets of removed tretrahedrons (for test purpose)\n\
          - 3 = extract all facets of kept tetrahedrons (for test purpose)\n\
     -i : remove tetrahedrons with at least <min_intersect> rays going through them.\n\
     -iw : use a number of intersections larger than <min_intersect> for \"large\" tetrahedrons\n\
     -mxf : use maxflow algorithm, with a threshold of <nb-intersections>, to remove tetras\n\
     -a : remove facets that do not satisfy a constraint on normal angles.\n\
         + if <normals-angle> > 0, rm facets where the angle between the facet normal and a vertex normal is greater than angle\n\
         + if <normals-angle> < 0, rm facets where the angle between the facet normal and the sum of vertex normals is greater than |angle|.\n\
           Angle value from 0 to 180; default value 180 means \"no angle constraint\".\n\
     -ct : remove tetrahedrons that have 3 facets on the surface (rough patches).\n\
     -sm : try to smooth the surface. Replace each point p by <lambda> * p + (1 - <lambda>) * neighbours_mean; repeat <nb_iter> times.\n\
           if <lambda> <= 0., use default value of 0.8; if <nb_iter> < 0, do a weighted mean based on normal angles.\n\
";
  std::cout << usage1;
  std::cout << "     -lg : remove tetrahedrons with too long edges (greater than  <lg_coef> * mean-edge-length. Default value of " << DEF_LGR_COEF<< " if <lg_coef> = 0." << std::endl;
  std::cout << "     -s : remove tetrahedrons with too large facets (surface greater than  <surf_coef> * mean-edge-length * mean-edge-length. Default value of " << DEF_SURF_COEF<< " if <surf_coef> = 0." << std::endl;
  exit(1);
}

static double box_lgr(0.);


/* the cgal data file being read, this routine can be called with various extraction parameters
input: argc, argv : args in usual form
    T : delaunay triangulation
    normal, pcolors : normals and colors of points
    nbcam : nb of valid cameras
    cams_index : index of camera positions in the points list
    bad_cameras : vector of bad cameras
    dx, dy, dz : size of bounding box (of pmvs points)
    edge_mean : sqare mean edge length
    comment0 : head of comment ( contains program name and cgla filename)
output: ply result is written to the file specified by args
Returns: 0 if OK, -1 if error
 */
int do_extract(int argc,char **argv,Delaunay &T,std::vector<Point> &normals,PointColor &pcolors,int nbcams,int *cams_index,TPoint &bad_cameras,float dx, float dy, float dz,float edge_mean,float edge_mean1,char *comment0) {
#ifdef __USE_POSIX
  struct timespec tstart, tend;
#else
  time_t tstart, tend;
#endif
  float lgr_coef(-1.), surf_coef(-1.);
  int theta = 180;
  bool flip_face=false;
  TrParams params;
  params.cosinus_thresh = 2.;
  if(argc < 1 || argc > 18) return -1;
  int lgr = 0;
  ExtractType check_type(XTR_DEFAULT);
  for(int i = 0;i < argc;i++)
    lgr += strlen(argv[i]) + 1;
  int k = strlen(comment0);
  char *comment = new char[lgr + k];
  strcpy(comment,comment0);
  for(int i = 0;i < argc;i++) {
    strcpy(comment + k,argv[i]);
    k += strlen(argv[i]);
    *(comment+ k++) = ' ';
  }
  *(comment + k - 1) = 0;
  std::cout << "COMM " << comment << std::endl;
  for (int i = 1;i < argc;) {
    int incr = 2;
    int ires;
    float fres[2];
    if(mygetopt("-e",OPT_INT,i,argc,argv,&ires)) {
      if(ires < 0 || ires > 3) return -1;
      params.extract_mode = ires;
    } else if(mygetopt("-i",OPT_INT,i,argc,argv,&ires)) {
      if(check_type == XTR_MAXFLOW) return -1;
      check_type = XTR_STD;
      ires *= 2;
      if (ires <= 0) ires = 2;
      else if(ires > MAX_INTERSECT) ires = MAX_INTERSECT;
      params.nb_intersect = ires;
    } else if(mygetopt("-iw",OPT_NOARGS,i,argc,argv,&ires)) {
      if(check_type == XTR_MAXFLOW) return -1;
      check_type = XTR_STD_VOL;
      incr = 1;
    } else if(mygetopt("-mxf",OPT_INT,i,argc,argv,&ires)) {
      if(check_type != XTR_DEFAULT) return -1;
      check_type = XTR_MAXFLOW;
      ires *= 2;
      if(ires > MAX_INTERSECT) ires = MAX_INTERSECT;
      else if (ires <= 0) ires = 2;
      params.nb_intersect = ires - 1;  // le cout est n - ires
    } else if(mygetopt("-a",OPT_INT,i,argc,argv,&theta)) {
      if(theta < 0) {
	theta = -theta;
	params.moy_normal = true;
      }
    } else if(mygetopt("-lg",OPT_FLOAT,i,argc,argv,&lgr_coef)) {
      if (lgr_coef == 0.) lgr_coef = DEF_LGR_COEF;
      if (lgr_coef >= 0.) params.do_clean |= CLEAN_LGR;
    } else if(mygetopt("-s",OPT_FLOAT,i,argc,argv,&surf_coef)) {
      if (surf_coef == 0.) surf_coef = DEF_SURF_COEF;
      if (surf_coef >= 0.) {
	surf_coef *= surf_coef;
	params.do_clean |= CLEAN_SURF;
      }
    } else if(mygetopt("-ct",OPT_NOARGS,i,argc,argv,&ires)) {
      params.do_clean |= CLEAN_TETRA;
      incr = 1;
    } else if(mygetopt("-flip",OPT_NOARGS,i,argc,argv,&ires)) {
        flip_face=true;
        printf("Flipping Meshes on Output!\n");
        incr = 1;
    }else if(mygetopt("-sm",OPT_FLOAT,i,argc,argv,fres,2)) {
      params.smooth_coef = fres[0];
      if(params.smooth_coef <= 0.) params.smooth_coef = 0.8;
      else if (params.smooth_coef >= 1.) {
	std::cout << "Bad smooth coef\n";
	return -1;
      }
      params.smooth_nb_iter = (int)fres[1];
      if (params.smooth_nb_iter == 0) params.smooth_nb_iter = 1;
      incr = 3;
    } else
      return -1;
    i += incr;
  }
  if(check_type == XTR_DEFAULT) check_type = XTR_STD;
  if(check_type == XTR_STD_VOL)
    //    params.box_volume = dx * dy * dz;
    params.average_volume = edge_mean * edge_mean1 * 0.11785;  // a^3 * sqrt(2) / 12
  else
    params.average_volume = 0.;
  params.extract_type = check_type;
  theta %= 360;
  if(theta > 180) theta = 360 - theta;
  double v = (M_PI * (double)theta) / 180.;
  std::cout << "Normals test angle " << theta << " (" << v << " radians)." << std::endl;
  params.cosinus_thresh = (theta == 180) ? -2 : cos(v);
#ifdef TRIANGDEBUG
  debug_stop = 4 ; 
  debug_vis = 4; 
  gv_on = true;
#else
  debug_stop = 0 ;
  debug_vis = 0; 
#endif
  box_lgr = (dx < dy) ? dy : dx;
  if(box_lgr < dz) box_lgr = dz;
 
  float l_threshold = 0.;
  float surf = dx * dy;
  if(surf < (dy * dz)) surf = (dy * dz);
  if(surf < (dx * dz)) surf = (dx * dz);
  if(edge_mean > 0.) {  // sqared mean edge
    l_threshold = edge_mean;
    surf = edge_mean;
  } else {
    return -1;
    //    l_threshold = box_lgr * box_lgr;
  }
  if(lgr_coef >= 0.) {
      params.lgr_threshold = l_threshold * lgr_coef * lgr_coef;
  }
  if(surf_coef >= 0.) {
      params.surf_threshold = surf * surf_coef;
  }
  //normals.clear();
  try {
    if(params.do_clean > 0)
      std::cout << "Clean : surf " << params.surf_threshold << " (/ average " << surf << ") , lgr " << sqrt(params.lgr_threshold) << " (/ average " << sqrt(l_threshold) << ")" << std::endl;
    CGAL::Geomview_stream *gv;
    if(debug_vis > 0) {
      gv = new CGAL::Geomview_stream(CGAL::Bbox_3(0,0,0, 2, 2, 2));
      gv->set_bg_color(CGAL::Color(200, 200, 200));
    }
    delaunay_extract(argv[0],T,normals,pcolors,nbcams,cams_index,bad_cameras,params,*gv,comment,flip_face);
    if(debug_vis > 0) delete gv;
  }
  catch(char const *_e) {
    std::cout << "ERROR " << _e << std::endl;
    return 1;
    
  }
  return 0;
}

/*
  reads a line of options from stdin
  input : nmax : nb max of options
  output : pargv : pointer to the table of pointers to options
  return : nb of options
 */
int read_args(char ***pargv, int nmax)
{
  char *tmp = new char[1024];
  char **xargv = new char*[nmax];
  *pargv = xargv;
  std::cout << "args: ";
  std::cin.getline(tmp, 1024);
  char *ps = tmp;
  int argc = 0;
  bool in_word = false;
  for (int i = 0;i < 1024;i++) {
    if(*tmp == 0) break;
    if (isspace(*tmp)) {
      if(in_word) {
	*tmp = 0;
	in_word = false;
      }
      tmp++;
    } else {
      if (! in_word) {
	if(argc >= (nmax - 1)) return argc;
	in_word = true;
	xargv[argc++] = tmp;
      }
      tmp++;
    }
  }
  return argc;
}

int main(int argc,char **argv)
{
#ifdef __USE_POSIX
  struct timespec tstart, tend;
#else
  time_t tstart, tend;
#endif
  if(argc < 3) usage(argv[0]);
  bool is_interactif = false;

  if (strcmp(argv[2],"-i") == 0) is_interactif = true;

  Delaunay T;
  PointColor pcolors;
  std::vector<Point> normals;
#ifdef __USE_POSIX
  clock_gettime(CLOCK_REALTIME,&tstart);
#else
  tstart = time(NULL);
#endif
  CGAL::Bbox_3 bb;
  int nbcams;
  int *cams_index;
  std::map<int, VisiblePatches*> image_patches;
  TPoint bad_cameras;
  float dx,dy,dz;
  float edge_mean, tetra_coefs[2];
  try {
    read_cgal_data(argv[1],T,pcolors,normals,bb,&nbcams,&cams_index,image_patches,bad_cameras,CG_BADCAMS,&edge_mean,tetra_coefs);
#ifdef __USE_POSIX
    clock_gettime(CLOCK_REALTIME,&tend);
#else
    tend = time(NULL);
#endif
    std::cout << "Read took " << delta_t(&tstart,&tend) << "s" << std::endl;
    dx = bb.xmax() - bb.xmin();
    dy = bb.ymax() - bb.ymin();
    dz = bb.zmax() - bb.zmin();
    // marquage des cameras utiles(V)
    for(int icam = 0;icam < nbcams;icam++) {
      pcolors[cams_index[icam]] = CGAL::Color(0,255,0);
    }
  }
  catch(char const *_e) {
  std::cout << "ERROR " << _e << std::endl;
    return 1;
    
  }
  float edge_mean1 = sqrt(edge_mean);
  std::cout << "BOX : " << bb << std::endl;
  std::cout << "Average edge : " << edge_mean1 << ", barycenter add coefs " << tetra_coefs[0] << " " << tetra_coefs[1] << std::endl;

  int lgr = strlen(argv[1]) + 12;
  char tmp[512];
  int lg2 = 0;
  if(tetra_coefs[0] > 0.) {
    snprintf(tmp,512," (%f %f) ",tetra_coefs[0],tetra_coefs[1]);
    lg2 = strlen(tmp);
    lgr += lg2;
  }
  char *comment = new char[lgr + 2];
  strcpy(comment,"triangclean ");
  strcat(comment,argv[1]);
  if(lg2 > 0)
    strcat(comment,tmp);
  *(comment + lgr) = ' ';
  *(comment + lgr + 1) = 0;

  try {
    while(1) {
      int xargc;
      char **xargv;
      if (is_interactif) {
	xargc = read_args(&xargv,15);
      } else {
	xargc = argc - 2;
	xargv = argv+2;
      }
      int res = do_extract(xargc,xargv,T,normals,pcolors,nbcams,cams_index,bad_cameras,dx,dy,dz,edge_mean,edge_mean1,comment);
      if (is_interactif) {
	delete[] xargv;
	if (res < 0)
	  usage(argv[0],false);
      } else {
	if (res < 0) usage(argv[0]);
	break;
      }
    }
  }
  catch(char const *_e) {
  std::cout << "ERROR " << _e << std::endl;
    return 1;
    
  }

    //Segment s = Segment(Point(bb.xmin(), bb.ymin(),bb.zmin()),Point(bb.xmax(), bb.ymax(),bb.zmax()));
    //  box_lgr = s.squared_length();
 return 0;
}
