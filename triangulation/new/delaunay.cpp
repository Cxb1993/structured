#include "delaunay.h"
#include <time.h>

#ifdef _OPENMP
#include <omp.h>
#endif

//static int dbg_cam(8850), dbg_pt(2);
static int dbg_cam(-1), dbg_pt(2);

static double box_lgr(0.);
static int min_intersect = 2;  // le bit 0 du nb d'intersections est reservé 
// pour marquer les tetras incidents aux points vus, donc min_intersect doit etre multiple de 2

void usage(char *prog) {
  std::cout << "Usage : " << prog << " <cam_points> <points-basename> [-D debug-level] [-o outfile] [-a coef_min coef_max] " << std::endl;
  std::cout << "   Make a delaunay triangulation with PMVS points and camera positions," << std::endl;
  std::cout << "   and compute intersections of tetrahedrons with rays issued from camera points." << std::endl << std::endl;
  std::cout << "     <cam_points> : ply file of camera positions, with color attribute (generated by tool **drawcameras.py**)." << std::endl;
  std::cout << "     <points-basename> : basename for .ply and .patch files" << std::endl;
  std::cout << "     -D : debug level, level / 10 for display, level % 10 for interactivity" << std::endl;
  std::cout << "     -o : result file (default output.cgal)." << std::endl;
  std::cout << "     -a : add a point (barycenter) to \"large\" tretrahedrons, i.e with an edge >= coef_min*average-edge-length and <= coef_max*average-edge-length." << std::endl;
  exit(1);
}


/*
  find tetras intersected by the ray joining camera num icam to point num ipt
input : points vector of points
        cells : incident cells at camera point
	ifacets : vector of facets of incident cells to be tested.
	itf0 : where to start in ifacets
	icam : cam index
	vcam : vertex of cam
	ipt : target point index
	
 output: marked_cells : intersected tetras are added to this vector
         stats : statistics 
 return : (iterator) where to start in the camera incident facet vector. (try to optimize intial facets search)
 */
std::vector<Facet>::iterator check_point(Delaunay &Tr,std::vector<Cell_handle> &marked_cells,TPoint &points,std::vector<Cell_handle> &cells,std::vector<Facet> &ifacets,std::vector<Facet>::iterator itf0,int icam,Vertex_handle vcam,int ipt,TrStats *stats,CGAL::Geomview_stream &gv) throw(const char *){
  if(debug_stop > 1) std::cout << "\n\nCAM  " << icam << " : " << ipt << std::endl;
  if(debug_stop > 1) {
    prompt("GO");
  }
  Segment seg(points[icam].first,points[ipt].first);
  if(debug_stop > 1) std::cout << "NB CELLS " << std::distance(cells.begin(),cells.end()) << 
    " FACETS : " << ifacets.size() << std::endl;

  Circulator ifc0(ifacets.begin(),ifacets.end(),itf0);
  Circulator ifc = ifc0;
  std::vector<Facet> *facets = new std::vector<Facet>();
  do {
    Facet f = *ifc++;
    facets->push_back(f);
  }  while (ifc != ifc0);

  Segment newseg;
  Intersect in_inter, out_inter;
  in_inter.int_type = INT_VERTEX;
  in_inter.v1 = vcam;
  bool first_step = true;
  std::vector<Facet>::iterator itres;
  int step = 0;
  int err = 0;
  while (facets->size() > 0) {
    if(debug_vis > 2) {
      draw_all(gv,Tr);
      draw_seg(gv,seg);
      //      draw_tetra(Tr,cells,gv);
      draw_facets(Tr,*facets,gv);
      if (icam == 172 && ipt == 22) {
	prompt("TETRAS ");
	//draw_all(gv,Tr);
	gv.clear();
	draw_seg(gv,seg);
	draw_line_tetra(Tr,cells,gv);
	prompt("Next ");
	/*std::vector<Cell_handle> xcells;
	for(std::vector<Cell_handle>::iterator itc = cells.begin();itc != cells.end();itc++) {
	  xcells.clear();
	  xcells.push_back(*itc);
	  draw_all(gv,Tr);
	  draw_seg(gv,seg);
	  draw_line_tetra(Tr,xcells,gv);
	  prompt("Next cell "); 
	} */
      }
    }
    stats->nb_test_facets += facets->size();
    int nb0 = facets->size();
    if(icam == dbg_cam && ipt == dbg_pt && step == 0) {
      err = 1;
    } else
      err = 0;
    step++;
    int nb_tested = 0;
    facets = intersect(&err,&nb_tested,seg,in_inter,out_inter,facets,Tr,marked_cells,newseg,stats,gv);
    stats->nb_tested_facets += nb_tested;
    if(first_step) {
      stats->nb_tested_lv0 += nb_tested;
      first_step = false;
      int n = out_inter.intersected_facet;
      itres = ifacets.begin() + n;
    }
    if(err != 0) {
      printf("ERROR: no intersection; cam %d, point %d, step %d\n",icam,ipt,step);
      throw("Could not reach target point");
    }

    in_inter = out_inter;
    
    if(debug_stop > 1) {
      std::cout << "SEG " << seg << ", " << facets->size() << " FACETS" <<std::endl;
      if(debug_stop > 3)   prompt("");
    }
    //seg = newseg;
  }
  return itres;
}

void dump_cell(Cell_handle &c) {
  std::cout << "CELL ";
  for(int i= 0;i < 4;i++) {
    int j = c->vertex(i)->info();
    std::cout << " " << j;
  }
  std::cout << std::endl;
}

/*
  find tetras intersected by the rays joining camera num icam to all its visible points
input : points vector of points (bit 0 if index is 1 if point is a vertex)
	icam : cam index
	vpatches : vector of indices of points visible from the camera
	
 output: stats : statistics 
	 Nb of intersections is added to field 'info' of cells
 */
void check_cam(Delaunay &Tr,TPoint &points,int icam,VisiblePatches *vpatches,TrStats *stats,CGAL::Geomview_stream &gv) throw(const char *){
  
  Locate_type lt;
  int li, lj;
  Cell_handle c = Tr.locate(points[icam].first,lt,li,lj);
  if(lt != Delaunay::VERTEX) 
    throw("query point should be on a vertex\n");
  Vertex_handle v = c->vertex(li);
  std::vector<Cell_handle> cells;
#pragma omp critical
  {
  Tr.finite_incident_cells(v,std::back_inserter(cells));
  }
  std::vector<Facet> facets;
  if(icam == dbg_cam) {
    std::cout << "ICAM " << icam << ", li " << li << " " << (v->info() >> 1) << ", N " << cells.size()
	      << ", PT " << points[icam].second << " " << points[icam].first << std::endl;
    dump_cell(c);
    for (std::vector<Cell_handle>::iterator itc = cells.begin();itc != cells.end();itc++)
      dump_cell(*itc);
  }
#ifdef _OPENMP
#pragma omp critical
  {
      for (std::vector<Cell_handle>::iterator it = cells.begin();it != cells.end();it++) 
	(*it)->info() = MAX_INTERSECT;
  }

#endif
  for (std::vector<Cell_handle>::iterator it = cells.begin();it != cells.end();it++) {
    int ip = (*it)->index(v);
#ifndef _OPENMP
    (*it)->info() = MAX_INTERSECT;
#endif
    facets.push_back(Facet(*it,ip));
  }
  //  CGAL::Container_from_circulator<Facet> itc(ifc0);
  // optimisation : voir mail 385
  stats->nb_tetra0 += facets.size();
  stats->nb_rayons += vpatches->size();

  int k = 0;
  bool first = true;
  for(VisiblePatches::iterator itp = vpatches->begin();itp != vpatches->end();itp++) {
    if (! (points[*itp].second & 1)) continue;
    std::vector<Cell_handle> marked_cells;
    std::vector<Facet>::iterator itf = facets.begin();
    std::vector<Facet>::iterator it2 =  check_point(Tr,marked_cells,points,cells,facets,itf,icam,v,*itp,stats,gv);
#pragma omp critical
    {
      for(std::vector<Cell_handle>::iterator it = marked_cells.begin();it != marked_cells.end();it++) {
	if((*it)->info() < MAX_INTERSECT) (*it)->info() += 2;
      }
    }
    
    if(first) {
      itf = it2;
      first = false;
    }
  }

}

/*
  dump data to binary file
  - 4 bytes version (CGxx)
  - delaunay
  - 6 * float : bounding box (without cams)
  - 3 * float : average edge length (in pmvs points), 0 0 or coefs min and max used for points addition in large tetras
  - int : nbcams = nb of "good" cameras
  - npts * 3 uchars : colors of points
  - bool : 'with_normals'
     - npts * 3-floats : normals of finite vertices
  - nbcams * 2 * int : camera indexes (in finite vertices list), original cameras nums
  - nbcell * int : finites cells info
  - nbcams * : points visible by each camera
    - int : cam num
    - int : nb of visible points
    - nbv * int : indexes (in finite vertices list) of visible points
 - int : nbbadcams
 - nbbadcams * 3 float : bad cameras coords
 */
void dump_data(char *file,Delaunay &T,TPoint &cam_points,TPoint &points,PointColor &pcolors,std::vector<Point> &normals,CGAL::Bbox_3 &bb,int nbpts0,std::vector<int> &cameras,std::vector<int> &bad_cameras,std::map<int, VisiblePatches*> &image_patches,float edge_mean,float *tetra_coefs)
{
  std::ofstream oFileT;
  int nbcams = cameras.size();
  int totpts = points.size();
  oFileT.open(file,std::ios::out);
  CGAL::set_binary_mode(oFileT);
  oFileT.write(file_version,4);
  oFileT << T;
  float box[6];
  box[0] = bb.xmin();
  box[1] = bb.ymin();
  box[2] = bb.zmin();
  box[3] = bb.xmax();
  box[4] = bb.ymax();
  box[5] = bb.zmax();
  oFileT.write((char *)box,sizeof(box));
  oFileT.write((char *)&edge_mean,sizeof(float));
  oFileT.write((char *)tetra_coefs,2 * sizeof(float));
  oFileT.write((char *)&nbcams,sizeof(nbcams));

  Delaunay::Finite_vertices_iterator it;
  int cam_index[2 * nbcams];
  int j = 0;
  int k = 0;
  int *new_vert_index = new int[totpts];
  for(it = T.finite_vertices_begin();it != T.finite_vertices_end();it++,j++) {
    unsigned char tmp[3];
    unsigned int i = it->info() >> 1;
    if(i >= nbpts0) cam_index[k++] = j;
    new_vert_index[i] = j;
    tmp[0] = pcolors[i].red();
    tmp[1] = pcolors[i].green();
    tmp[2] = pcolors[i].blue();
    oFileT.write((char *)tmp,(int)sizeof(tmp));
  }
  // save actual cam index
  for(int i = 0;i < nbcams;i++)
    cam_index[k++] = cameras[i];
  bool with_normals = false;
  if(normals.size() != pcolors.size()) {
    oFileT.write((char *)&with_normals,(int)sizeof(with_normals));
  } else {
    with_normals = true;
    oFileT.write((char *)&with_normals,sizeof(with_normals));
    float tmp[3];
    for(it = T.finite_vertices_begin();it != T.finite_vertices_end();it++) {
      unsigned int i = it->info() >> 1;
      tmp[0] = normals[i].x();
      tmp[1] = normals[i].y();
      tmp[2] = normals[i].z();
      oFileT.write((char *)tmp,sizeof(tmp));
    }
  }
  // cameras indexes
  oFileT.write((char *)cam_index,2 * nbcams * sizeof(int));
  // cells info
  Delaunay::Finite_cells_iterator cit;
  int icell = 0;
  for (cit = T.finite_cells_begin(); cit != T.finite_cells_end(); ++cit,icell++) {
    int i = cit->info();
    //    std::cout << "I " << cit->info() << " : " << i << std::endl;
    oFileT.write((char *)&i,sizeof(i));
  }
  // visible points by camera : num cam, nb points, points indices
  for(int i = 0;i < nbcams;i++) {
    int icam = cameras[i];
    std::map<int, VisiblePatches*>::iterator itv = image_patches.find(icam);
    if(itv == image_patches.end()) throw("Internal error : corrupted cam list\n");
    VisiblePatches *patches = itv->second;
    int tmp[2];
    tmp[0] = i;
    
    int *pi0 = new int[patches->size()];
    int *pi = pi0;
    int nv = 0;
    for (VisiblePatches::iterator it = patches->begin();it != patches->end();it++) {
      if(! (points[*it].second & 1)) continue;
      *pi++ = new_vert_index[*it];
      nv++;
    }
    tmp[1] = nv;
    oFileT.write((char *)tmp,sizeof(tmp));
    if (nv > 0)
      oFileT.write((char *)pi0,nv * sizeof(int));
    delete[] pi0;
    
  }

  // bad cameras coords
  int nb_badcams = bad_cameras.size();
  oFileT.write((char *)&nb_badcams,sizeof(nb_badcams));
  float *pf0 = new float[3 * nb_badcams];
  float *pf = pf0;
  int *pi0 = new int[nb_badcams];
  int *pi = pi0;
  for (int i = 0;i < nb_badcams;i++) {
    int icam = bad_cameras[i];
    Point p = cam_points[icam].first;
    *pf++ = p.x();
    *pf++ = p.y();
    *pf++ = p.z();
    *pi++ = icam;
  }
  oFileT.write((char *)pf0,3 * nb_badcams * sizeof(float));
  // and actual cam indexes
  oFileT.write((char *)pi0,nb_badcams * sizeof(int));
  delete[] pf0;
  delete[] pi0;

  oFileT.close();
}


// visu geomview de demo/Triangulation_3_Geomview_demos/Triangulation_3_demo.cpp
int main(int argc,char **argv)
{
  timespec tstart, tstart2, tend;
  int firstcam = 0;
  char *outfile = "output.cgal";
  float tetra_coefs[] = {0.,0.};
  if(argc < 3 || argc > 9) usage(argv[0]);
  for (int i = 3;i < argc;) {
    int incr = 2;
    int ires;
    if(mygetopt("-D",OPT_INT,i,argc,argv,&ires)) {
      debug_stop = ires % 10;
      debug_vis = ires / 10;
      if(debug_vis > 0) gv_on = true;
    } else if(mygetopt("-o",OPT_STRING,i,argc,argv,&outfile)) {
      ;
    } else if(mygetopt("-a",OPT_FLOAT,i,argc,argv,tetra_coefs,2)) {
      incr = 3;
      if (tetra_coefs[0] < 0.) tetra_coefs[0] = 0.;
      if (tetra_coefs[1] < tetra_coefs[0]) tetra_coefs[1] = tetra_coefs[0];
    } else usage(argv[0]);
    i += incr;
  }

  int nbcams(0), nbpts0(0);
  TPoint points;
  TPoint cam_points;
  PointColor pcolors;
  PointColor cam_colors;
  std::vector<Point> normals;
  std::vector<Point> cam_normals;
  std::map<int, VisiblePatches*> image_patches;
  CGAL::Bbox_3 bb;
  // *****
  // Read points
  clock_gettime(CLOCK_REALTIME,&tstart);
  try {
    read_ply(argv[1],cam_points,cam_normals,cam_colors);
    nbcams = cam_points.size();
    if(cam_normals.size() == 0)
      cam_normals.resize(nbcams,Point(1.,1.,1.));
    char tmp[512];
    snprintf(tmp,512,"%s.ply",argv[2]);
    bool no_points = false;
    std::ifstream ifstr;
    ifstr.open(tmp);
    if(! ifstr.good())
      no_points = true;
    else {
      ifstr.close();
      bb = read_ply(tmp,points,normals,pcolors);
      double dx = bb.xmax() - bb.xmin();
      double dy = bb.ymax() - bb.ymin();
      double dz = bb.zmax() - bb.zmin();
      Segment s = Segment(Point(bb.xmin(), bb.ymin(),bb.zmin()),Point(bb.xmax(), bb.ymax(),bb.zmax()));
      box_lgr = s.squared_length();
      if(normals.size() < points.size()) normals.clear();
    }
    snprintf(tmp,512,"%s.patch",argv[2]);
    read_patches(tmp,0,nbcams,points,image_patches,no_points);
    nbpts0 = points.size();
    if(no_points) {
      normals.clear();
      pcolors.resize(points.size(),CGAL::Color(128,128,128));
    }
  }
  catch(char const *_e) {
    std::cout << "ERROR " << _e << std::endl;
    return 1;
    
  }
  clock_gettime(CLOCK_REALTIME,&tend);
  std::cout << "Read took " << delta_t(&tstart,&tend) << "s" << std::endl;
  // shift point indexes  : we need bit 0 to flag points eliminated by delaunay
  for (TPoint::iterator it = points.begin();it != points.end();it++) {
    it->second <<= 1;
  }
  // 1. delaunay on pmvs points
  clock_gettime(CLOCK_REALTIME,&tstart);
  Delaunay T( points.begin(),points.end() );
  float edge_mean = mean_edge(T);

  // add points if needed
  if (tetra_coefs[0] > 0.) {
    clock_gettime(CLOCK_REALTIME,&tstart2);
   //  add a point to "large" cells
    // 1st compute edge length average
    float edge_min = tetra_coefs[0] * tetra_coefs[0] * edge_mean;
    float edge_max = tetra_coefs[1] * tetra_coefs[1] * edge_mean;
    // add points
    int nbadd = 0;
    //    for (int i = 0; i < 10;i++) {
      int nb = add_cells(T,edge_min,edge_max,points,pcolors,normals);
      nbadd += nb;
      //      std::cout << "ITER " << i << " added " << nb << " => " << nbadd << std::endl;
      //    }
    clock_gettime(CLOCK_REALTIME,&tend);
    std::cout << "splitting large cells took " << delta_t(&tstart2,&tend) << "s, " << nbadd << " points added" << std::endl;

    nbpts0 = points.size();
  }
  // Check if the nb of points is compatible with the size of info()
  size_t k = points.size() - 1;
  if (k != (points[k].second >> 1)) {
    std::cout << "Sorry! the number of points " << k << " is greater than the index capacity." << std::endl;
    exit(2);
  }
#if 1
  // verif points
  for(Delaunay::Finite_vertices_iterator it = T.finite_vertices_begin();it != T.finite_vertices_end();it++) {
    int j = it->info() >> 1;
    if (j < 0 || j > points.size()) {
      std::cout << "BAD J " << j << std::endl;
      exit(2);
    }
    std::pair<Point,unsigned int> p = points[j];
    if(p.second != j << 1) {
      std::cout << "ERR on point " << p.first << ", j " << j << " " << p.second << std::endl;
      exit(2);
    }
  }
#endif

  // add cameras points to delaunay
  std::vector<int> cameras;
  std::vector<int> bad_cameras;
  int j = nbpts0;
  for(int icam = 0;icam < nbcams;icam++) {
    std::map<int, VisiblePatches*>::iterator it = image_patches.find(icam);
    if (it != image_patches.end()) {
      std::pair<Point,unsigned int> p = cam_points[icam];
      p.second = j++;
      points.push_back(p);
      normals.push_back(cam_normals[icam]);
      pcolors.push_back(cam_colors[icam]);
      cameras.push_back(icam);
    } else
      bad_cameras.push_back(icam);
  }
  TPoint::iterator it = points.begin() + nbpts0;
  T.insert(it,points.end());
  std::cout << nbpts0 << " points, " << cameras.size() << " valid cameras / " << nbcams << std::endl;

  clock_gettime(CLOCK_REALTIME,&tend);
  std::cout << "Delaunay took " << delta_t(&tstart,&tend) << "s" << std::endl;
  int nb_vertices = std::distance(T.finite_vertices_begin(),T.finite_vertices_end());
  std::cout << "VERTICES : " << nb_vertices << ", CELLS: " << std::distance(T.finite_cells_begin(),T.finite_cells_end()) << std::endl;

  // init cells info
  for (Delaunay::Finite_cells_iterator cit = T.finite_cells_begin(); cit != T.finite_cells_end(); ++cit) {
    cit->info() = 0;
  }

  clock_gettime(CLOCK_REALTIME,&tstart);

  for(Delaunay::Finite_vertices_iterator it = T.finite_vertices_begin();it != T.finite_vertices_end();it++) {
    unsigned int j = it->info() >> 1;
    it->info() |= 1;
    points[j].second |= 1;
  }
  clock_gettime(CLOCK_REALTIME,&tend);
  std::cout << "CHECK points took " << delta_t(&tstart,&tend) << "s" << std::endl;
  std::cout << "NB removed by delaunay " << (points.size() - nb_vertices) << std::endl;
  clock_gettime(CLOCK_REALTIME,&tstart);

  CGAL::Geomview_stream *gv;
  if(debug_vis > 0) {
    gv = new CGAL::Geomview_stream(CGAL::Bbox_3(0,0,0, 2, 2, 2));
    gv->set_bg_color(CGAL::Color(200, 200, 200));
  }
  if(debug_vis > 0 && nbpts0 < 10000) draw_all(*gv,T);
#ifdef _OPENMP
  omp_set_nested(0);
  //  omp_set_dynamic(1);
  omp_set_dynamic(0); //  nb of threads will not depend on load
  int nbT = omp_get_num_procs();
  std::cout << "NB Threads " << nbT << std::endl;
#else
  int nbT = 1;
#endif
  //std::cout << nbT << " threads, " << nbcells << " cells" <<std::endl;
    //    std::map<int, VisiblePatches*>::iterator it  = image_patches.begin();
    bool error = false;
    TrStats *pstats[nbT];
    for(int i = 0;i < nbT;i++)
      pstats[i] = new TrStats();
#pragma omp parallel for num_threads(nbT)
    //    for(std::vector<int>::iterator itc = cameras.begin();itc != cameras.end();itc++) {
    //      int icam = *itc;
  for(int i = firstcam;i < cameras.size();i++) {
    if (error) continue;
    int icam = cameras[i];
#ifdef _OPENMP
    int numth = omp_get_thread_num();
#else
    int numth = 0;
#endif
    try {
      //    for(int icam = 0;icam < nbcams;icam++) {
      std::map<int, VisiblePatches*>::iterator it = image_patches.find(icam);
      VisiblePatches vpatches(0);
      VisiblePatches *pvpatches;
      if (it != image_patches.end()) {
	pvpatches = it->second;
      } else {
	pvpatches = &vpatches;
      }
      if(debug_stop > 0 || nbcams > 10) 
	//	std::cout << "START CAM " << icam << " , " << pvpatches->size() << " PTS" << std::endl;
	printf("THRD %d / %d START CAM %d, %d\n",numth,nbT,icam,pvpatches->size());
      if(debug_stop > 0) {
	prompt("GO");
      }
      check_cam(T,points,i + nbpts0,pvpatches,pstats[numth],*gv);
    }
    catch(char const *_e) {
      std::cout << "ERROR (cam " << icam << " , thr " << numth << ") : " << _e << std::endl;
      if(debug_vis > 0) delete gv;
      error = true;
      //return 1;
    }

  }
  clock_gettime(CLOCK_REALTIME,&tend);
  if (error) return 10;
  std::cout << "Ray tracing took " << delta_t(&tstart,&tend) << "s" << std::endl;
 
  TrStats *stats = pstats[0];
  for(int i = 1;i < nbT;i++)
    stats->sum(pstats[i]);
  std::cout << stats->nb_tested_facets << " / " << stats->nb_test_facets << " facets tested, " 
	    << stats->nb_tested_lv0 << " tested at cam points." << std::endl
	    << stats->nb_tot_intersect << " intersections found (" << stats->nb_intv << " on vertex, " 
	    << stats->nb_int_edge << " on edge." << std::endl;
  std::cout << "BBOX : " << bb << std::endl;
  std::cout << "DX " << bb.xmax() - bb.xmin() << ", DY " << bb.ymax() - bb.ymin() << ", DZ " << bb.zmax() - bb.zmin() << ", average edge length " << sqrt(edge_mean) << std::endl;
  clock_gettime(CLOCK_REALTIME,&tstart);
  dump_data(outfile,T,cam_points,points,pcolors,normals,bb,nbpts0,cameras,bad_cameras,image_patches,edge_mean,tetra_coefs);
  clock_gettime(CLOCK_REALTIME,&tend);
  std::cout << "Dump took " << delta_t(&tstart,&tend) << "s" << std::endl;
  std::cout << "STATS : " << stats->nb_tetra0 << " tetras de cameras, " << stats->nb_rayons << " rayons." << std::endl;

  if(debug_vis > 0) delete gv;
  return 0;
#if 0
  clock_gettime(CLOCK_REALTIME,&tstart);
  delaunay_extract("newtr.ply",T,min_intersect,normals,pcolors,0,*gv);
  clock_gettime(CLOCK_REALTIME,&tend);
  std::cout << "Extraction took " << delta_t(&tstart,&tend) << "s" << std::endl;
  gv->set_wired(true);
  *gv << T;
  char ch;
  std::cin >> ch;
#endif
  if(debug_vis > 0) delete gv;
  return 0;
}
